using UnityEngine;
using System.Collections;

public class BulbScript : MonoBehaviour
{
    // These should really be scripts in the individual objects instead
    public SpriteRenderer bulbRoundGlow;
    public SpriteRenderer bulbFilamentGlow;
    public SpriteRenderer bulbConeGlow;
    public SpriteRenderer logoShadow;

    void Start()
    {
        bulbRoundGlow.color = new Color(1, 1, 1, 0);
        bulbFilamentGlow.color = new Color(1, 1, 1, 0);
        bulbConeGlow.color = new Color(1, 1, 1, 0);
        logoShadow.color = new Color(1, 1, 1, 0);

        StartCoroutine(_Run());
    }

    IEnumerator _Run()
    {
        yield return new WaitForSeconds(1);

        StartCoroutine(_BulbFadeOutIn(0, 1, 0, 1, .02f)); while (bulbFading) yield return null;

        yield return new WaitForSeconds(.4f);

        while (true)
        {
            // Strong flicker
            StartCoroutine(_BulbFadeOutIn(0, .3f, 0, 1, .1f)); while (bulbFading) yield return null;
            StartCoroutine(_BulbFadeOutIn(0, .3f, 0, 1, .1f)); while (bulbFading) yield return null;
            StartCoroutine(_BulbFadeOutIn(0, .6f, 0, 1, .6f)); while (bulbFading) yield return null;

            // Wait half a second
            for (int i = 0; i < 30; i++)
                yield return null;

            // Fade in & out
            for (int i = 0; i < 3; i++)
            {
                StartCoroutine(_BulbFadeOutIn(0.4f, .007f, 0, 1, .007f));
                while (bulbFading) yield return null;
            }
        }
    }

    bool bulbFading = false;

    // Fades out then fades back in.
    // Cuts the garbage generated by the infinite loop by half (by combining a FadeOut with a FadeIn).
    // Running the menu for a while will still trigger the GC. For the best optimization,
    // no StartCoroutines can be called at all in there, but the code would look unreadable.
    IEnumerator _BulbFadeOutIn(float dest0, float rate0, int rest, float dest1, float rate1)
    {
        // Causes the coroutine to yield itself until the previous one is finished.
        // In practice this only makes the code above cleaner while making syncing difficult
        // and overall impossible to use in infinite loops.
        //while (bulbFading)
        //    yield return null;

        // Fades out
        bulbFading = true;
        while (bulbConeGlow.color.a > dest0)
        {
            // use Color.Lerp() next time  holy shit
            bulbRoundGlow.color += new Color(0, 0, 0, -rate0);
            bulbFilamentGlow.color += new Color(0, 0, 0, -rate0);
            bulbConeGlow.color += new Color(0, 0, 0, -rate0);
            logoShadow.color += new Color(0, 0, 0, -rate0);
            yield return null;
        }
        bulbRoundGlow.color = new Color(1, 1, 1, dest0);
        bulbFilamentGlow.color = new Color(1, 1, 1, dest0);
        bulbConeGlow.color = new Color(1, 1, 1, dest0);
        logoShadow.color = new Color(1, 1, 1, dest0);

        // Waits <rest> number of frames
        for (int i = 0; i < rest; i++)
            yield return null;

        // Fades in
        while (bulbConeGlow.color.a < dest1)
        {
            bulbRoundGlow.color += new Color(0, 0, 0, rate1);
            bulbFilamentGlow.color += new Color(0, 0, 0, rate1);
            bulbConeGlow.color += new Color(0, 0, 0, rate1);
            logoShadow.color += new Color(0, 0, 0, rate1);
            yield return null;
        }
        bulbRoundGlow.color = new Color(1, 1, 1, dest1);
        bulbFilamentGlow.color = new Color(1, 1, 1, dest1);
        bulbConeGlow.color = new Color(1, 1, 1, dest1);
        logoShadow.color = new Color(1, 1, 1, dest1);
        bulbFading = false;
    }
}
